# Замеры времени работы оригинального GraceHashJoin

## Замер №1

Схема тьюпла:
- key: ui64
- payload: ui64

Распределение данных в левом и правом потоках:
- Уникальные числа в диапазоне [start; end]
- Размер левого потока сильно меньше размера правого потока
- Для каждого значения меньшего потока есть либо ровно одна пара из большего потока
- Крэф-т селективности влияет на то, какой процент значений из меньшего потока имеют пару в большем потоке
  - 100 %, значит, у всех тьюплов из меньшего потока есть пара
  - 50 %, значит, только у половины тьюплов из меньшего потока есть пара
  - ...

Как проводился бенчмарк:
- Размер тьюпла рассчитывался как сумма размеров данных в сыром C++ представлении (для данного замера размер тьюпда равен: sizeof(ui64) + sizeof(ui64) = 16)
- Был создан граф исполнения, который содержит ноду джоин, два входных потока и один выходной. Итератор по выходному потоку построчно читает данные и проверяет джоин на корректность.
- Бенчмарк замеряет работу всего графа исполнения

Результаты:
|                    | {5000, 25000} | {10000, 50000} | {20000, 100000} | {50000, 250000} |
|--------------------|---------------|----------------|-----------------|-----------------|
| Селективность 100% | 10ms, 45MB/s  | 20ms, 45MB/s   | 39ms, 46MB/s    | 98ms, 46MB/s    |
| Селективность  50% | 9ms, 50MB/s   | 20ms, 45MB/s   | 37ms, 59MB/s    | 94ms, 48MB/s    |
| Селективность  20% | 7ms, 65MB/s   | 14ms, 65MB/s   | 29ms, 63MB/s    | 94ms, 48MB/s    |

*размеры входных потоков указаны в формате {little_stream_size, large_stream_size}

## Замер №2

Схема тьюпла:
- key: ui64
- payload: ui64

Распределение данных в левом и правом потоках:
- Размер левого потока сильно меньше размера правого потока
- Потоки имеют разное распределение данных:
  - В одном из потоков половина тьюплов -- уникальные числа в диапазоне [start1; end1], вторая половина тьюплов имеет одинаковое значение ключа (скошенный датасет)
  - Во втором потоке все значения -- уникальные числа в диапазоне [start1; end2]
- Крэф-т селективности зафиксирован и равен 100%

Как проводился бенчмарк:
- Размер тьюпла рассчитывался как сумма размеров данных в сыром C++ представлении (для данного замера размер тьюпда равен: sizeof(ui64) + sizeof(ui64) = 16)
- Был создан граф исполнения, который содержит ноду джоин, два входных потока и один выходной. Итератор по выходному потоку построчно читает данные и проверяет джоин на корректность.
- Бенчмарк замеряет работу всего графа исполнения

Результаты:
|                      | {5000, 25000} | {10000, 50000} | {20000, 100000} | {50000, 250000} |
|----------------------|---------------|----------------|-----------------|-----------------|
| Меньший поток скошен | 10ms, 45MB/s  | 19ms, 48MB/s   | 94ms, 19MB/s    | 390ms, 11MB/s   |
| Больший поток скошен | 11ms, 41MB/s  | 26ms, 35MB/s   | 65ms, 28MB/s    | 138ms, 33MB/s    |

*размеры входных потоков указаны в формате {little_stream_size, large_stream_size}

## Замер №3

Схема тьюпла:
- key: ui64
- payload: ui64

Распределение данных в левом и правом потоках:
- Размер левого потока сильно меньше размера правого потока
- Оба потока состоят из тьюплов с одним и тем же ключом (Cross Join)

Как проводился бенчмарк:
- Размер тьюпла рассчитывался как сумма размеров данных в сыром C++ представлении (для данного замера размер тьюпда равен: sizeof(ui64) + sizeof(ui64) = 16)
- Был создан граф исполнения, который содержит ноду джоин, два входных потока и один выходной. Итератор по выходному потоку построчно читает данные и проверяет джоин на корректность.
- Бенчмарк замеряет работу всего графа исполнения

Результаты:
| {100, 10000}   | {200, 20000}    | {400, 40000}    |
|----------------|-----------------|-----------------|
| 252ms, 626KB/s | 1005ms, 314KB/s | 3703ms, 170KB/s |

*размеры входных потоков указаны в формате {little_stream_size, large_stream_size}

## Замер №4

Схема тьюпла:
- key: {ui64, str}
- payload: str

Распределение данных в левом и правом потоках:
- Размер левого потока сильно меньше размера правого потока
- Ключи всех тьюплов в обоих потоках уникальные
- Для каждого значения меньшего потока есть либо ровно одна пара из большего потока
- Крэф-т селективности зафиксирован и равен 100%

Как проводился бенчмарк:
- Размер тьюпла рассчитывался как сумма размеров данных в сыром C++ представлении. Для данного бенчмарка размеры тьюпла будут меняться, чтобы оценить влияние размера тьюпла на скорость работы
- Был создан граф исполнения, который содержит ноду джоин, два входных потока и один выходной. Итератор по выходному потоку построчно читает данные и проверяет джоин на корректность.
- Бенчмарк замеряет работу всего графа исполнения

Результаты:
|                 | {5000, 25000} | {10000, 50000} | {20000, 100000} | {50000, 250000} |
|-----------------|---------------|----------------|-----------------|-----------------|
| Tuple size = 16 | 14ms, 81MB/s  | 29ms, 78MB/s   | 57ms, 80MB/s    | 141ms, 81MB/s   |
| Tuple size = 32 | 14ms, 147MB/s | 26ms, 158MB/s  | 54ms, 152MB/s   | 149ms, 138MB/s  |
| Tuple size = 64 | 21ms, 185MB/s | 38ms, 204MB/s  | 77ms, 202MB/s   | 165ms, 235MB/s  |
| Tuple size = 96 | 25ms, 228MB/s | 42ms, 272MB/s  | 87ms, 263MB/s   | 214ms, 267MB/s  |

*размеры входных потоков указаны в формате {little_stream_size, large_stream_size}